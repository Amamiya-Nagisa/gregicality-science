package gregicality.science.loaders.recipes;

import gregicality.science.common.GCYSciConfig;
import gregicality.science.common.item.GAExplosive;
import gregicality.science.common.item.GAMetaBlocks;
import gregicality.science.loaders.recipes.categories.*;
import gregicality.science.loaders.recipes.categories.circuits.CircuitRecipes;
import gregicality.science.loaders.recipes.categories.machines.MachineCraftingRecipes;
import gregicality.science.loaders.recipes.chain.*;
import gregicality.science.api.GCYSciLog;
import gregtech.api.GTValues;
import gregtech.api.GregTechAPI;
import gregtech.api.recipes.*;
import gregtech.api.recipes.ingredients.IntCircuitIngredient;
import gregtech.api.unification.OreDictUnifier;
import gregtech.api.unification.material.Material;
import gregtech.api.unification.material.properties.BlastProperty;
import gregtech.api.unification.material.properties.PropertyKey;
import gregtech.api.unification.ore.OrePrefix;
import gregtech.api.unification.stack.MaterialStack;
import gregtech.api.unification.stack.UnificationEntry;
import gregtech.common.items.MetaItems;
import gregtech.common.items.behaviors.TurbineRotorBehavior;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.IRecipe;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fml.common.registry.ForgeRegistries;
import net.minecraftforge.oredict.OreDictionary;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static gregicality.science.api.GCYSciMaterials.*;
import static gregicality.science.common.item.GAMetaItems.*;
import static gregicality.science.api.materials.GAMaterialFlags.DISABLE_AUTOGENERATED_MIXER_RECIPE;
import static gregicality.science.loaders.recipes.GCYSciRecipeMaps.*;
import static gregicality.science.loaders.recipes.helper.HelperMethods.*;
import static gregtech.api.GTValues.L;
import static gregtech.api.recipes.GTRecipeHandler.removeRecipesByInputs;
import static gregtech.api.recipes.ModHandler.removeRecipeByName;
import static gregtech.api.recipes.RecipeMaps.*;
import static gregtech.api.recipes.ingredients.IntCircuitIngredient.getIntegratedCircuit;
import static gregtech.api.unification.material.MarkerMaterials.Color.White;
import static gregtech.api.unification.material.Materials.*;
import static gregtech.api.unification.material.info.MaterialFlags.*;
import static gregtech.api.unification.ore.OrePrefix.*;

/**
 * Primary Recipe Registration Class
 */
public class RecipeHandler {

    /**
     * Used for Gem Implosion
     */
    private static final ItemStack[] EXPLOSIVES = new ItemStack[]{
            GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.POWDER_BARREL, 48),
            new ItemStack(Blocks.TNT, 24),
            MetaItems.DYNAMITE.getStackForm(12),
            GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.ITNT, 6)};

    /**
     * GT Material Handler registration.
     * This probably isn't the method you are looking for.
     */
    public static void register() {

//        turbineBlade.addProcessingHandler(PropertyKey.INGOT, RecipeHandler::processTurbine); todo material processing handlers
//        ingot.addProcessingHandler(PropertyKey.INGOT, RecipeHandler::processIngot);
//        nugget.addProcessingHandler(PropertyKey.INGOT, RecipeHandler::processNugget);
//        dust.addProcessingHandler(PropertyKey.GEM, RecipeHandler::processGem);
//        lens.addProcessingHandler(PropertyKey.GEM, RecipeHandler::processLens);
//
//        dust.addProcessingHandler(PropertyKey.FLUID, RecipeHandler::registerPlasmaCondenserRecipes);
        ingot.addProcessingHandler(PropertyKey.BLAST, RecipeHandler::registerStellarForgeRecipes);
    }


    /**
     * Main Method for initializing recipe chains,
     * located in the "recipes/chain" directory.
     */
    public static void initChains() {
        NaquadahChain.init();
        NuclearChain.init();
        PolymerChain.init();
        PlatinumSludgeGroupChain.init();
        TungstenChain.init();
        REEChain.init();
        Batteries.init();
        RheniumChain.init();
        UHVMaterials.init();
        PEEKChain.init();
        ZylonChain.init();
        FullereneChain.init();
        BariumChain.init();
        UraniumChain.init();
        IodineChain.init();
        ZirconChain.init();
        ZincChain.init();
        AmmoniaChain.init();
        SodiumCarbonateChain.init();
        BrineChain.init();
        FusionElementsChain.init();
        NanotubeChain.init();
        VariousChains.init();
        SuperconductorsSMDChain.init();
        FusionComponents.init();
        NiobiumTantalumChain.init();
        SensorEmitter.init();
        SeleniumChain.init();
        WormholeGeneratorChain.init();
        CosmicChain.init();
        UltimateMaterials.init();
        DigitalInterfaces.init();
        InsulationWireAssemblyChain.init();
        WetwareChain.init();
        OpticalChain.init();
        CombinedChains.init();
        OrganometallicChains.init();
        QuantumDotsChain.init();
        HNIWChain.init();
    }

    /**
     * Main Recipe Addition Method for recipes outside of autogenerated
     * recipes and chemistry chains.
     */
    public static void initRecipes() {
        RecipeOverride.init();
        CircuitRecipes.init();
        MachineCraftingRecipes.init();
        ComponentRecipes.init();
        MetaItemRecipes.init();
        CasingRecipes.init();
        SuperconductorRecipes.init();
        MiscRecipes.init();
        registerGreenHouseRecipes();
    }

    /**
     * Ingot Material Handler. Generates:
     *
     * + Mixer Recipes for GTCE Materials we add
     */
    private static void processIngot(OrePrefix ingot, Material material) {
        // Ingot Composition
        processIngotComposition(material);
    }

    /**
     * Generates Mixer (or Large Mixer) recipes for GTCE Materials we add.
     */
    private static void processIngotComposition(Material material) {
        if (material.getMaterialComponents().size() <= 1 || material.getBlastTemperature() == 0 || material.hasFlag(DISABLE_AUTOGENERATED_MIXER_RECIPE))
            return;

        int fluidCount = (int) material.getMaterialComponents().stream().filter(mat -> mat.material.hasProperty(PropertyKey.FLUID) && !(mat.material.hasProperty(PropertyKey.DUST))).count();
        int itemCount = material.getMaterialComponents().size() - fluidCount;

        // Try to fit in Mixer
        RecipeBuilder<?> builder;
        if (itemCount <= MIXER_RECIPES.getMaxInputs()
                && fluidCount <= MIXER_RECIPES.getMaxFluidInputs())

            builder = MIXER_RECIPES.recipeBuilder();

        // Try to fit in Large Mixer
        else if (itemCount <= LARGE_MIXER_RECIPES.getMaxInputs()
                && fluidCount <= LARGE_MIXER_RECIPES.getMaxFluidInputs())

            builder = LARGE_MIXER_RECIPES.recipeBuilder()
                    .notConsumable(new IntCircuitIngredient(material.getMaterialComponents().size()));

        // Cannot fit in either
        else {
            GCYSciLog.logger.warn("Material {} has too many material components to generate a recipe in either normal or large mixer.", material.getUnlocalizedName());
            return;
        }

        int totalMaterial = 0;
        for (MaterialStack stack : material.getMaterialComponents()) {
            int amount = (int) stack.amount;

            if (stack.material.hasProperty(PropertyKey.DUST))
                builder.input(dust, stack.material, amount);

            else if (stack.material.hasProperty(PropertyKey.FLUID))
                builder.fluidInputs(stack.material.getFluid(1000 * amount));

            totalMaterial += amount;
        }

        builder.output(dust, material, totalMaterial)
               .duration((int) (material.getAverageMass() * totalMaterial))
               .EUt(30)
               .buildAndRegister();
    }

    /**
     * Gem Material Handler. Generates:
     *
     * + Laser Engraver Gem Recipes
     * + Implosion Compressor Gem Recipes
     * + Gem Hammer Recipes
     *
     * - Removes GTCE Gem Implosion Recipes
     */ // TODO
    private static void processGem(OrePrefix dustPrefix, Material material) {

        // Gem Implosion Recipes
        if (!material.hasFlag(CRYSTALLIZABLE) && !material.hasFlag(EXPLOSIVE) && !material.hasFlag(FLAMMABLE)) {

            RecipeBuilder<?> builder;

            removeRecipesByInputs(IMPLOSION_RECIPES, OreDictUnifier.get(dustPrefix, material, 4), new ItemStack(Blocks.TNT, 2));

            // It isn't uncommon for some GemMaterials to disable one or more of these prefixes.
            // Lets just check for both to be safe
            boolean hasFlawless = !OreDictUnifier.get(gemFlawless, material).isEmpty();
            boolean hasExquisite = !OreDictUnifier.get(gemExquisite, material).isEmpty();

            // Laser Engraver Recipes
            if (hasFlawless)

                // Gem -> Flawless
                LASER_ENGRAVER_RECIPES.recipeBuilder().duration(2400).EUt(2000)
                        .input(gem, material, 4)
                        .notConsumable(craftingLens, White)
                        .output(gemFlawless, material)
                        .buildAndRegister();

            if (hasExquisite)

                // Flawless -> Exquisite
                LASER_ENGRAVER_RECIPES.recipeBuilder().duration(2400).EUt(2000)
                        .input(gemFlawless, material, 4)
                        .notConsumable(craftingLens, White)
                        .output(gemExquisite, material)
                        .buildAndRegister();

            // Implosion Compressor Recipes
            for (ItemStack explosive : EXPLOSIVES) {

                // Dust -> Gem
                builder = IMPLOSION_RECIPES.recipeBuilder()
                        .input(dust, material, 4)
                        .output(gem, material, 3)
                        .output(dustTiny, DarkAsh, 2);
                builder .applyProperty("explosives", explosive);
                builder .buildAndRegister();

                if (hasFlawless) {

                    // Gem -> Flawless
                    builder = IMPLOSION_RECIPES.recipeBuilder()
                            .input(gem, material, 3)
                            .output(gemFlawless, material)
                            .output(dustTiny, DarkAsh, 2);
                    builder .applyProperty("explosives", explosive);
                    builder .buildAndRegister();
                }

                if (hasExquisite) {

                    // Flawless -> Exquisite
                    builder = IMPLOSION_RECIPES.recipeBuilder()
                            .input(gemFlawless, material, 3)
                            .output(gemExquisite, material)
                            .output(dustTiny, DarkAsh, 2);
                    builder .applyProperty("explosives", explosive);
                    builder .buildAndRegister();
                }
            }
        }

        // Gem Hammer Recipes
        if (!OreDictUnifier.get(toolHeadHammer, material).isEmpty()) {

            ModHandler.addMirroredShapedRecipe(String.format("gem_hammer_%s", material.toString()), MetaItems.HARD_HAMMER.getStackForm(material),
                    "GG ", "GGS", "GG ",
                    'G', new UnificationEntry(gem, material),
                    'S', new UnificationEntry(stick, Wood));
        }
    }

    /**
     * Nugget Material Handler. Generates:
     *
     * - GTCE Packer / Unpacker recipes, to be registered elsewhere if configured.
     */
    private static void processNugget(OrePrefix nugget, Material material) {

        // Packer / Unpacker removal, to be readded elsewhere depending on Config settings
        removeRecipesByInputs(PACKER_RECIPES, OreDictUnifier.get(nugget, material, 9), getIntegratedCircuit(1));
        removeRecipesByInputs(UNPACKER_RECIPES, OreDictUnifier.get(ingot, material, 1), getIntegratedCircuit(1));
    }

    /**
     * Turbine Material Handler. Generates:
     *
     * + Small, Medium, Large, and Huge Turbine Assembler Recipes
     * + Turbine Blade Forming Press Recipes
     *
     * - Removes GTCE Recipes for Turbines and Blades, as well as the Handcrafting Turbine Blades Recipes
     */
    private static void processTurbine(OrePrefix toolPrefix, Material material) {

        // Remove GTCE Turbine/Blade recipes
        removeRecipesByInputs(ASSEMBLER_RECIPES, OreDictUnifier.get(plate, material, 5), OreDictUnifier.get(screw, material, 2), getIntegratedCircuit(10));
        removeRecipesByInputs(ASSEMBLER_RECIPES, OreDictUnifier.get(stickLong, Titanium), OreDictUnifier.get(turbineBlade, material, 8));
        removeRecipeByName(String.format("gtadditions:turbine_blade_%s", material));

        // Generate the Turbine item with proper stats
        ItemStack hugeTurbineRotorStackForm = HUGE_TURBINE_ROTOR.getStackForm();
        ItemStack largeTurbineRotorStackForm = LARGE_TURBINE_ROTOR.getStackForm();
        ItemStack mediumTurbineRotorStackForm = MEDIUM_TURBINE_ROTOR.getStackForm();
        ItemStack smallTurbineRotorStackForm = SMALL_TURBINE_ROTOR.getStackForm();

        TurbineRotorBehavior.getInstanceFor(smallTurbineRotorStackForm).setPartMaterial(smallTurbineRotorStackForm, material);
        TurbineRotorBehavior.getInstanceFor(mediumTurbineRotorStackForm).setPartMaterial(mediumTurbineRotorStackForm, material);
        TurbineRotorBehavior.getInstanceFor(largeTurbineRotorStackForm).setPartMaterial(largeTurbineRotorStackForm, material);
        TurbineRotorBehavior.getInstanceFor(hugeTurbineRotorStackForm).setPartMaterial(hugeTurbineRotorStackForm, material);

        // Turbine Recipes
        ASSEMBLER_RECIPES.recipeBuilder().duration(200).EUt(400)
                .circuitMeta(0)
                .input(turbineBlade, material, 4)
                .input(stickLong, Titanium)
                .outputs(smallTurbineRotorStackForm)
                .buildAndRegister();

        ASSEMBLER_RECIPES.recipeBuilder().duration(400).EUt(800)
                .circuitMeta(1)
                .input(turbineBlade, material, 8)
                .input(stickLong, Tungsten)
                .outputs(mediumTurbineRotorStackForm)
                .buildAndRegister();

        ASSEMBLER_RECIPES.recipeBuilder().duration(800).EUt(1600)
                .circuitMeta(2)
                .input(turbineBlade, material, 16)
                .input(stickLong, Osmium)
                .outputs(largeTurbineRotorStackForm)
                .buildAndRegister();

        ASSEMBLER_RECIPES.recipeBuilder().duration(1600).EUt(3200)
                .circuitMeta(3)
                .input(turbineBlade, material, 32)
                .input(stickLong, Rutherfordium)
                .outputs(hugeTurbineRotorStackForm)
                .buildAndRegister();

        // Turbine Blade recipe
        FORMING_PRESS_RECIPES.recipeBuilder().duration(20).EUt(256)
                .input(plateDouble, material, 5)
                .input(screw, material, 2)
                .output(toolPrefix, material)
                .buildAndRegister();
    }

    /**
     * Lens Material Handler. Generates:
     *
     * + Exquisite Gem -> Lens Recipes
     *
     * - Plate -> Lens Recipes
     */
    private static void processLens(OrePrefix gem, Material material) {

        removeRecipesByInputs(LATHE_RECIPES, OreDictUnifier.get(plate, material));

        if (!OreDictUnifier.get(gemExquisite, material).isEmpty()) {
            LATHE_RECIPES.recipeBuilder().duration(2400).EUt(30)
                    .input(gemExquisite, material)
                    .output(lens, material)
                    .output(dust, material, 2)
                    .buildAndRegister();
        } else {
            LATHE_RECIPES.recipeBuilder().duration(2400).EUt(30)
                    .input(plate, material)
                    .output(lens, material)
                    .output(dustTiny, material, 2)
                    .buildAndRegister();
        }
    }

    /**
     * Green House Recipe creation.
     */
    private static void registerGreenHouseRecipes() {

        final List<Object> fertilizers = Arrays.asList(
            null, 1000,
            new ItemStack(Items.DYE, 1, 15), 900,
            OreDictUnifier.get(dust, OrganicFertilizer), 600
        );

        final List<Item> inputs = Arrays.asList(
                Items.CARROT,
                Item.getItemFromBlock(Blocks.CACTUS),
                Items.REEDS,
                Item.getItemFromBlock(Blocks.BROWN_MUSHROOM),
                Item.getItemFromBlock(Blocks.RED_MUSHROOM),
                Items.BEETROOT);

        // Create Recipes for Vanilla crops
        for (int i = 0; i < fertilizers.size() / 2; i++) {

            List<RecipeBuilder<?>> recipes = new ArrayList<>();

            ItemStack fertilizer = (ItemStack) fertilizers.get(i * 2);
            int duration = (int) fertilizers.get(i * 2 + 1);

            // Potato
            recipes.add(GREEN_HOUSE_RECIPES.recipeBuilder().duration(duration)
                    .circuitMeta(i)
                    .fluidInputs(Water.getFluid(2000))
                    .notConsumable(new ItemStack(Items.POTATO))
                    .outputs(new ItemStack(Items.POTATO, i))
                    .chancedOutput(new ItemStack(Items.POISONOUS_POTATO, 1), 100, 50));

            // Melon
            GREEN_HOUSE_RECIPES.recipeBuilder().duration(1000)
                    .circuitMeta(i)
                    .fluidInputs(Water.getFluid(2000))
                    .notConsumable(new ItemStack(Items.MELON_SEEDS))
                    .outputs(new ItemStack(Items.MELON, i))
                    .chancedOutput(new ItemStack(Items.MELON_SEEDS), 100, 50)
                    .buildAndRegister();

            // Pumpkin
            GREEN_HOUSE_RECIPES.recipeBuilder().duration(1000)
                    .circuitMeta(i)
                    .fluidInputs(Water.getFluid(2000))
                    .notConsumable(new ItemStack(Items.PUMPKIN_SEEDS))
                    .outputs(new ItemStack(Blocks.PUMPKIN, i))
                    .chancedOutput(new ItemStack(Items.PUMPKIN_SEEDS), 100, 50)
                    .buildAndRegister();

            for (Item input : inputs) {

                recipes.add(GREEN_HOUSE_RECIPES.recipeBuilder().duration(duration)
                        .circuitMeta(i)
                        .fluidInputs(Water.getFluid(2000))
                        .notConsumable(new ItemStack(input))
                        .outputs(new ItemStack(input, i)));
            }

            if (fertilizer != null)
                recipes.stream()
                       .map(r -> r.inputs(fertilizer))
                       .forEach(RecipeBuilder::buildAndRegister);
        }

        // Search for seeds in the OreDictionary to find other recipes to add
        Arrays.stream(OreDictionary.getOreNames()).filter(name -> name.startsWith("seed")).forEach(name -> {

            String oreName = name.substring(4);

            if (oreName.length() <= 0)
                return;

            String seedName = "seed" + titleCase(oreName);
            String cropName = "essence" + titleCase(oreName);

            List<ItemStack> registeredSeeds = OreDictionary.getOres(seedName, false);
            List<ItemStack> registeredCrops = OreDictionary.getOres(cropName, false);

            if (registeredSeeds.isEmpty() || registeredCrops.isEmpty())
                return;

            ItemStack seed = registeredSeeds.get(0).copy();
            ItemStack essence = registeredCrops.get(0).copy();

            GREEN_HOUSE_RECIPES.recipeBuilder().duration(1000)
                    .fluidInputs(Water.getFluid(2000))
                    .circuitMeta(0)
                    .notConsumable(seed)
                    .outputs(essence)
                    .chancedOutput(seed, 100, 50)
                    .buildAndRegister();

            essence = registeredCrops.get(0).copy();
            essence.setCount(3);
            GREEN_HOUSE_RECIPES.recipeBuilder().duration(600)
                    .fluidInputs(Water.getFluid(2000))
                    .circuitMeta(2)
                    .notConsumable(seed)
                    .input(dust, OrganicFertilizer)
                    .outputs(essence)
                    .chancedOutput(seed, 100, 50)
                    .buildAndRegister();
        });
    }

    /**
     * Recipe Registration method for any recipes that need to iterate over
     * ALL registered materials. Generates:
     *
     * - Large Centrifuge autogenerated recipes
     * - Matter Replication Recipes
     */
    public static void runRecipeGeneration() {
        for (Material material : GregTechAPI.MATERIAL_REGISTRY) {

            // Decomposition Recipes
            if (material.hasProperty(PropertyKey.FLUID)) {
                OrePrefix prefix = material.hasProperty(PropertyKey.DUST) ? dust : null;
                //processDecomposition(prefix, material); // todo is this actually needed anymore?
            }
        }
    }

    // TODO This method needs work
    private static void processDecomposition(OrePrefix decomposePrefix, Material material) {
        if (material.getMaterialComponents().isEmpty() || !material.hasFlag(DECOMPOSITION_BY_CENTRIFUGING) ||
                //disable decomposition if explicitly disabled for this material or for one of it's components
                material.hasFlag(DISABLE_DECOMPOSITION)) return;

        ArrayList<ItemStack> outputs = new ArrayList<>();
        ArrayList<FluidStack> fluidOutputs = new ArrayList<>();
        int totalInputAmount = 0;

        //compute outputs
        for (MaterialStack component : material.getMaterialComponents()) {
            totalInputAmount += component.amount;
            if (component.material.hasProperty(PropertyKey.DUST))
                outputs.add(OreDictUnifier.get(dust, component.material, (int) component.amount));
            else if (component.material.hasProperty(PropertyKey.FLUID))
                fluidOutputs.add(component.material.getFluid((int) (1000 * component.amount)));

        }

        //generate builder
        RecipeBuilder<?> builder;
        if (!material.hasFlag(DECOMPOSITION_BY_ELECTROLYZING)) {
            builder = LARGE_CENTRIFUGE_RECIPES.recipeBuilder()
                    .duration((int) Math.ceil(material.getAverageMass() * totalInputAmount * 1.5))
                    .EUt(30);
        } else {
            return;
        }
        builder.outputs(outputs);
        builder.fluidOutputs(fluidOutputs);

        //finish builder
        if (decomposePrefix != null) {
            builder.input(decomposePrefix, material, totalInputAmount);
        } else {
            builder.fluidInputs(material.getFluid(1000 * totalInputAmount));
        }
        if (material.hasFlag(DECOMPOSITION_REQUIRES_HYDROGEN)) {
            builder.fluidInputs(Hydrogen.getFluid(1000 * totalInputAmount));
        }

        //register recipe
        builder.buildAndRegister();
    }

    /**
     * Recipe Generation for any recipes that need to iterate over the entire Crafting Table recipe registry.
     *
     * Details on recipe registration in each individual method. It works only on recipes that
     * have exactly one unique Item input.
     */
    public static void generatedRecipes() {

        for (IRecipe recipe : ForgeRegistries.RECIPES) {

            switch(getSingleInputCount(recipe)) {
                case -1: continue;
                case 1: generate1to9Recipes(recipe); break;
                case 4: generate2x2Recipes(recipe); break;
                case 9: generate3x3Recipes(recipe); break;
            }
        }
    }

    /**
     * 3x3 Single Input Recipe Generation. Generates:
     *
     * + Compressor Recipes for 3x3 Crafting Recipes
     * + Packer Recipes for 3x3 Crafting Recipes
     *
     * - Removes handcrafting 3x3 Recipes for:
     *     - Blocks
     *     - Nuggets
     *     - All others
     *   depending on config values.
     */
    private static void generate3x3Recipes(IRecipe recipe) {

        ItemStack input = getTopLeft(recipe);
        ItemStack output = recipe.getRecipeOutput();

        // Exclude tinyDust->dust recipes, handled elsewhere
        if (output.getCount() != 1
         || hasOrePrefix(input, "dustTiny"))
            return;

        if (GCYSciConfig.GT5U.Remove3x3BlockRecipes && hasOrePrefix(output, "block"))
            removeRecipeByName(recipe.getRegistryName());

        else if (GCYSciConfig.GT5U.Remove3x3NuggetRecipes && hasOrePrefix(input, "nugget"))
            removeRecipeByName(recipe.getRegistryName());

        else if (GCYSciConfig.GT5U.Remove3x3MiscRecipes && !hasOrePrefix(output, "block") && !hasOrePrefix(input, "nugget"))
            removeRecipeByName(recipe.getRegistryName());

        PACKER_RECIPES.recipeBuilder().duration(100).EUt(4)
                .inputs(CountableIngredient.from(input, 9))
                .notConsumable(new IntCircuitIngredient(9))
                .outputs(output)
                .buildAndRegister();

        // Exclude Wheat, since it compresses to Plant Balls
        if (!ItemStack.areItemsEqual(input, new ItemStack(Items.WHEAT)))
            COMPRESSOR_RECIPES.recipeBuilder().duration(400).EUt(2)
                    .inputs(CountableIngredient.from(input, 9))
                    .outputs(output)
                    .buildAndRegister();
    }

    /**
     * 2x2 Single Input Recipe Generation. Generates:
     *
     * + Packer Recipes for 2x2 Crafting Recipes
     */
    private static void generate2x2Recipes(IRecipe recipe) {

        ItemStack input = getTopLeft(recipe);
        ItemStack output = recipe.getRecipeOutput();

        // Exclude smallDust->dust recipes and wire/cable compacting, handled elsewhere
        if (output.getCount() != 1
         || hasOrePrefix(input, "dustSmall")
         || hasOrePrefix(input, "wireGt")
         || hasOrePrefix(input, "cableGt"))
            return;

        // Add Packager 2x2 Recipes
        PACKER_RECIPES.recipeBuilder().duration(100).EUt(4)
                .inputs(CountableIngredient.from(input, 4))
                .notConsumable(new IntCircuitIngredient(4))
                .outputs(output)
                .buildAndRegister();
    }

    /**
     * 1 to 9 Single Input Recipe Generation. Generates:
     *
     * + Unpacker Recipes for 1 to 9 Crafting Recipes
     *
     * - Removes handcrafting 1 to 9 Recipes for:
     *     - Blocks
     *     - Nuggets
     *     - All others
     *   depending on config values.
     */
    private static void generate1to9Recipes(IRecipe recipe) {

        ItemStack input = getTopLeft(recipe);
        ItemStack output = recipe.getRecipeOutput();

        // Exclude dust->tinyDust recipes, handled elsewhere
        if (output.getCount() != 9
         || hasOrePrefix(output, "dustTiny"))
            return;

        if (GCYSciConfig.GT5U.Remove1to9BlockRecipes && hasOrePrefix(input, "block"))
            removeRecipeByName(recipe.getRegistryName());

        else if (GCYSciConfig.GT5U.Remove1to9NuggetRecipes && hasOrePrefix(output, "nugget"))
            removeRecipeByName(recipe.getRegistryName());

        else if (GCYSciConfig.GT5U.Remove1to9MiscRecipes && !hasOrePrefix(input, "block") && !hasOrePrefix(output, "nugget"))
            removeRecipeByName(recipe.getRegistryName());

        UNPACKER_RECIPES.recipeBuilder().duration(100).EUt(8)
                .inputs(input)
                .notConsumable(new IntCircuitIngredient(1))
                .outputs(output)
                .buildAndRegister();
    }

    /**
     * Plasma to Fluid plasma condenser recipes
     *
     * + Plasma Condenser recipes
     */
    private static void registerPlasmaCondenserRecipes(OrePrefix prefix, Material material) {
        if (material.hasProperty(PropertyKey.PLASMA) && material.hasProperty(PropertyKey.FLUID)) {
            int fluidAmount = material.hasFluid() ? GTValues.L : 100;

            PLASMA_CONDENSER_RECIPES.recipeBuilder().duration((int) material.getAverageMass()).EUt(960)
                    .fluidInputs(LiquidHelium.getFluid(100))
                    .fluidInputs(material.getPlasma(fluidAmount))
                    .notConsumable(new IntCircuitIngredient(1))
                    .fluidOutputs(Helium.getFluid(100))
                    .fluidOutputs(material.getFluid(fluidAmount))
                    .buildAndRegister();
        }
    }

    /**
     * Stellar Forge Recipes for materials with too large EBF temperatures
     *
     * + Stellar Forge EBF recipe analogues
     */
    private static void registerStellarForgeRecipes(OrePrefix prefix, Material material, BlastProperty property) {
        if (property.getBlastTemperature() >= 14500) {
            int duration = Math.max(1, (int) (material.getAverageMass() * 100L));

            ItemStack explosive;
            if (property.getBlastTemperature() >= 65000)
                explosive = GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.QCD_CHARGE);
            else if (property.getBlastTemperature() >= 35000)
                explosive = GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.LEPTONIC_CHARGE);
            else if (property.getBlastTemperature() >= 22500)
                explosive =  GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.TARANIUM_CHARGE);
            else
                explosive = GAMetaBlocks.EXPLOSIVE.getItemVariant(GAExplosive.ExplosiveType.NAQUADRIA_CHARGE);

            STELLAR_FORGE_RECIPES.recipeBuilder().duration(duration).EUt(7680)
                    .input(dust, material)
                    .inputs(explosive)
                    .fluidOutputs(material.getFluid(L))
                    .buildAndRegister();
        }
    }
}
